From ca83dca1c8fa4210231dd8ebda36c962b37015d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Vojt=C4=9Bch=20Hejsek?= <hejsekvojtech@gmail.com>
Date: Mon, 11 Sep 2017 19:21:47 +0300
Subject: [PATCH] Fix graphic

---
 include/gui/BufferQueueCore.h        |   4 --
 include/gui/IProducerListener.h      |   3 -
 include/media/openmax/OMX_IVCommon.h |   9 +++
 include/ui/Fence.h                   |  29 +-------
 include/ui/GraphicBufferMapper.h     |   7 ++
 include/ui/mediatek/GuiExtMonitor.h  | 133 +++++++++++++++++++++++++++++++++++
 include/ui/mediatek/IDumpTunnel.h    |  49 +++++++++++++
 include/ui/mediatek/RefBaseDump.h    |  34 +++++++++
 libs/gui/Android.mk                  |   1 -
 libs/gui/BufferQueueCore.cpp         |   1 -
 libs/gui/BufferQueueProducer.cpp     |   8 +--
 libs/gui/ConsumerBase.cpp            |  17 +----
 libs/gui/GLConsumer.cpp              |  11 +--
 libs/gui/IGraphicBufferProducer.cpp  |   7 --
 libs/gui/IProducerListener.cpp       |  26 -------
 libs/gui/Surface.cpp                 |   6 --
 libs/ui/Android.mk                   |   7 +-
 libs/ui/Fence.cpp                    |  20 +++---
 libs/ui/GraphicBufferMapper.cpp      |  12 ++++
 libs/ui/mediatek/Fence.cpp           |  58 +++++++++++++++
 libs/ui/mediatek/IDumpTunnel.cpp     | 116 ++++++++++++++++++++++++++++++
 libs/ui/mediatek/RefBaseDump.cpp     |  70 ++++++++++++++++++
 opengl/libs/EGL/Loader.cpp           |  85 ++--------------------
 opengl/libs/EGL/Loader.h             |   5 --
 opengl/libs/EGL/eglApi.cpp           |   6 ++
 vulkan/libvulkan/driver.cpp          |  73 ++-----------------
 26 files changed, 529 insertions(+), 268 deletions(-)
 create mode 100644 include/ui/mediatek/GuiExtMonitor.h
 create mode 100644 include/ui/mediatek/IDumpTunnel.h
 create mode 100644 include/ui/mediatek/RefBaseDump.h
 create mode 100644 libs/ui/mediatek/Fence.cpp
 create mode 100644 libs/ui/mediatek/IDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/RefBaseDump.cpp

diff --git a/include/gui/BufferQueueCore.h b/include/gui/BufferQueueCore.h
index 4e54ddb29..14b7e0448 100644
--- a/include/gui/BufferQueueCore.h
+++ b/include/gui/BufferQueueCore.h
@@ -185,10 +185,6 @@ class BufferQueueCore : public virtual RefBase {
     // PID of the process which last successfully called connect(...)
     pid_t mConnectedPid;
 
-    // mLinkedToDeath is used to set a binder death notification on
-    // the producer.
-    sp<IProducerListener> mLinkedToDeath;
-
     // mConnectedProducerListener is used to handle the onBufferReleased
     // notification.
     sp<IProducerListener> mConnectedProducerListener;
diff --git a/include/gui/IProducerListener.h b/include/gui/IProducerListener.h
index b7826c677..3848a6c85 100644
--- a/include/gui/IProducerListener.h
+++ b/include/gui/IProducerListener.h
@@ -41,7 +41,6 @@ class ProducerListener : public virtual RefBase
     // This is called without any lock held and can be called concurrently by
     // multiple threads.
     virtual void onBufferReleased() = 0; // Asynchronous
-    virtual bool needsReleaseNotify() = 0;
 };
 
 class IProducerListener : public ProducerListener, public IInterface
@@ -55,14 +54,12 @@ class BnProducerListener : public BnInterface<IProducerListener>
 public:
     virtual status_t onTransact(uint32_t code, const Parcel& data,
             Parcel* reply, uint32_t flags = 0);
-    virtual bool needsReleaseNotify();
 };
 
 class DummyProducerListener : public BnProducerListener
 {
 public:
     virtual void onBufferReleased() {}
-    virtual bool needsReleaseNotify() { return false; }
 };
 
 } // namespace android
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index f9b6f4b0f..808e6a589 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -165,6 +165,15 @@ typedef enum OMX_COLOR_FORMATTYPE {
      *  format for it. */
     OMX_COLOR_FormatYUV420Flexible = 0x7F420888,
 
+    OMX_COLOR_FormatVendorMTKYUV = 0x7F000001,
+    OMX_COLOR_FormatVendorMTKYUV_FCM = 0x7F000002,
+    OMX_COLOR_FormatVendorMTKYUV_UFO = 0x7F000003,
+    OMX_COLOR_FormatVendorMTKYUV_10BIT_H = 0x7F000004,
+    OMX_COLOR_FormatVendorMTKYUV_10BIT_V = 0x7F000005,
+    OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_H = 0x7F000006,
+    OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_V = 0x7F000007,
+    OMX_MTK_COLOR_FormatYV12 = 0x7F000200,
+    OMX_MTK_COLOR_FormatBitStream = 0x7F000300,
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index 48a7aa3c5..c26d49561 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -27,8 +27,6 @@
 #include <utils/String8.h>
 #include <utils/Timers.h>
 
-#include <experimental/optional>
-
 struct ANativeWindowBuffer;
 
 namespace android {
@@ -81,9 +79,6 @@ class Fence
     // becomes signaled when both f1 and f2 are signaled (even if f1 or f2 is
     // destroyed before it becomes signaled).  The name argument specifies the
     // human-readable name to associated with the new Fence object.
-    static sp<Fence> merge(const char* name, const sp<Fence>& f1,
-            const sp<Fence>& f2);
-
     static sp<Fence> merge(const String8& name, const sp<Fence>& f1,
             const sp<Fence>& f2);
 
@@ -98,27 +93,6 @@ class Fence
     // occurs then -1 is returned.
     nsecs_t getSignalTime() const;
 
-#if __cplusplus > 201103L
-    // hasSignaled returns whether the fence has signaled yet. Prefer this to
-    // getSignalTime() or wait() if all you care about is whether the fence has
-    // signaled. Returns an optional bool, which will have a value if there was
-    // no error.
-    inline std::experimental::optional<bool> hasSignaled() {
-        // The sync_wait call underlying wait() has been measured to be
-        // significantly faster than the sync_fence_info call underlying
-        // getSignalTime(), which might otherwise appear to be the more obvious
-        // way to check whether a fence has signaled.
-        switch (wait(0)) {
-            case NO_ERROR:
-                return true;
-            case -ETIME:
-                return false;
-            default:
-                return {};
-        }
-    }
-#endif
-
     // Flattenable interface
     size_t getFlattenedSize() const;
     size_t getFdCount() const;
@@ -136,6 +110,9 @@ class Fence
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
+    
+private:
+    void dump(int fd);
 };
 
 }; // namespace android
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index 4ccc6fddf..30a8a4b8e 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -70,6 +70,13 @@ class GraphicBufferMapper : public Singleton<GraphicBufferMapper>
     std::unique_ptr<Gralloc1::Device> mDevice;
 };
 
+extern "C" {
+
+    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
+            buffer_handle_t handle, int usage, const Rect& bounds, void** vaddr);
+
+}
+
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/include/ui/mediatek/GuiExtMonitor.h b/include/ui/mediatek/GuiExtMonitor.h
new file mode 100644
index 000000000..614d1c4f4
--- /dev/null
+++ b/include/ui/mediatek/GuiExtMonitor.h
@@ -0,0 +1,133 @@
+#ifndef __GUIEXT_MONITOR_H__
+#define __GUIEXT_MONITOR_H__
+
+
+#include <utils/String8.h>
+#include <utils/Singleton.h>
+#include <utils/KeyedVector.h>
+
+#include <ui/mediatek/IDumpTunnel.h>
+
+
+namespace android {
+
+template <typename TYPE, typename ITEM>
+class GuiExtMonitor : public Singleton<TYPE>
+{
+public:
+    GuiExtMonitor();
+    virtual ~GuiExtMonitor();
+
+    virtual status_t monitor(ITEM item);
+    virtual status_t unmonitor(ITEM item);
+
+    virtual status_t dump(String8& result, const char* prefix);
+
+protected:
+    status_t getProcessName();
+    virtual String8 getKeyName() const;
+
+protected:
+    bool mIsRegistered;
+    String8 mProcessName;
+    mutable Mutex mLock;
+    sp<BnDumpTunnel> mDumpTunnel;
+    KeyedVector<ITEM, int> mItemList;
+};
+
+
+//--------------------------------------------------------------------------------------------------
+
+template <typename TYPE, typename ITEM>
+GuiExtMonitor<TYPE, ITEM>::GuiExtMonitor()
+    : mIsRegistered(false) {
+    getProcessName();
+}
+
+
+template <typename TYPE, typename ITEM>
+GuiExtMonitor<TYPE, ITEM>::~GuiExtMonitor() {
+    Mutex::Autolock _l(mLock);
+
+    if (mIsRegistered) {
+        DumpTunnelHelper::getInstance().unregDump(getKeyName());
+        mIsRegistered = false;
+    }
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::monitor(ITEM item) {
+    Mutex::Autolock _l(mLock);
+
+    mItemList.add(item, 0);
+    if (!mIsRegistered)
+    {
+
+        class MonitorTunnel : public BnDumpTunnel {
+        public:
+            MonitorTunnel(GuiExtMonitor<TYPE, ITEM>* pMonitor)
+                : mMonitor(pMonitor) {}
+            virtual ~MonitorTunnel() {}
+
+            // IDumpTunnel interface
+            virtual status_t kickDump(String8& result, const char* prefix) {
+                return mMonitor->dump(result, prefix);
+            }
+
+        private:
+            GuiExtMonitor<TYPE, ITEM>* mMonitor;
+        };
+
+        mDumpTunnel = new MonitorTunnel(this);
+        if (DumpTunnelHelper::getInstance().regDump(mDumpTunnel, getKeyName())) {
+            mIsRegistered = true;
+        }
+    }
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::unmonitor(ITEM item) {
+    Mutex::Autolock _l(mLock);
+
+    mItemList.removeItem(item);
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::dump(String8& /*result*/, const char* /*prefix*/) {
+    return NO_ERROR;
+}
+
+
+template <typename TYPE, typename ITEM>
+status_t GuiExtMonitor<TYPE, ITEM>::getProcessName() {
+    int pid = getpid();
+    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
+    if (NULL != fp) {
+        const size_t size = 64;
+        char proc_name[size];
+        fgets(proc_name, size, fp);
+        fclose(fp);
+        mProcessName = proc_name;
+    } else {
+        mProcessName = "unknownProcess";
+    }
+    return NO_ERROR;
+}
+
+
+#define IMPLEMENT_META_GUIEXTMONITOR(TYPE, ITEM, NAME)                                  \
+    ANDROID_SINGLETON_STATIC_INSTANCE(TYPE);                                            \
+    template <>                                                                         \
+    String8 GuiExtMonitor<TYPE, ITEM>::getKeyName() const {                             \
+        return String8::format("%s-[%d:%s]", NAME, getpid(), mProcessName.string());    \
+    }
+
+
+}; // namespace android
+
+#endif
\ No newline at end of file
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
new file mode 100644
index 000000000..8f9b6636b
--- /dev/null
+++ b/include/ui/mediatek/IDumpTunnel.h
@@ -0,0 +1,49 @@
+#ifndef ANDROID_GUI_IDUMPTUNNEL_H
+#define ANDROID_GUI_IDUMPTUNNEL_H
+
+#include <binder/IInterface.h>
+#include <utils/Singleton.h>
+
+namespace android
+{
+
+class IDumpTunnel : public IInterface {
+protected:
+    enum {
+        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
+    };
+
+public:
+    DECLARE_META_INTERFACE(DumpTunnel);
+
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
+};
+
+class BnDumpTunnel : public BnInterface<IDumpTunnel>
+{
+    virtual status_t onTransact(uint32_t code,
+                                const Parcel& data,
+                                Parcel* reply,
+                                uint32_t flags = 0);
+};
+
+// helper class for libgui_ext dynamic linking
+class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
+    void* mSoHandle;
+    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
+    bool (*mUnregDumpPtr)(const String8&);
+
+public:
+    DumpTunnelHelper();
+    virtual ~DumpTunnelHelper();
+
+    // register tunnel into guiext-server with a given key name
+    // and need to unregister it back
+    // in general usage, need to use identical key name for reg/unreg pair
+    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
+    bool unregDump(const String8& key);
+};
+
+
+};
+#endif
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
new file mode 100644
index 000000000..1ac82187c
--- /dev/null
+++ b/include/ui/mediatek/RefBaseDump.h
@@ -0,0 +1,34 @@
+#ifndef ANDROID_REFBASE_DUMP_H__
+#define ANDROID_REFBASE_DUMP_H__
+
+#include <utils/String8.h>
+#include <ui/mediatek/GuiExtMonitor.h>
+
+namespace android {
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+class RefBaseMonitor : public GuiExtMonitor<RefBaseMonitor, RefBase*> {
+public:
+    RefBaseMonitor();
+    ~RefBaseMonitor() {}
+
+    // add refbase to the monitored list
+    status_t monitor(RefBase* pRb);
+
+    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
+    status_t dump(String8& result, const char* prefix);
+
+protected:
+    // build the key name to register in GuiExt Service
+    String8 getKeyName() const;
+
+private:
+    // if trackMe needed
+    bool mIsTracking;
+};
+
+
+}; // namespace android
+#endif
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 0889aaf55..b212f8a2a 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -54,7 +54,6 @@ LOCAL_SRC_FILES := \
 	DisplayEventReceiver.cpp \
 	GLConsumer.cpp \
 	GraphicBufferAlloc.cpp \
-	GraphicsEnv.cpp \
 	GuiConfig.cpp \
 	IDisplayEventConnection.cpp \
 	IGraphicBufferAlloc.cpp \
diff --git a/libs/gui/BufferQueueCore.cpp b/libs/gui/BufferQueueCore.cpp
index d610971b9..b61e851e0 100644
--- a/libs/gui/BufferQueueCore.cpp
+++ b/libs/gui/BufferQueueCore.cpp
@@ -59,7 +59,6 @@ BufferQueueCore::BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator) :
     mConsumerListener(),
     mConsumerUsageBits(0),
     mConnectedApi(NO_CONNECTED_API),
-    mLinkedToDeath(),
     mConnectedProducerListener(),
     mSlots(),
     mQueue(),
diff --git a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
index ff85eb5ce..196cad5bf 100644
--- a/libs/gui/BufferQueueProducer.cpp
+++ b/libs/gui/BufferQueueProducer.cpp
@@ -1131,11 +1131,8 @@ status_t BufferQueueProducer::connect(const sp<IProducerListener>& listener,
                         BQ_LOGE("connect: linkToDeath failed: %s (%d)",
                                 strerror(-status), status);
                     }
-                    mCore->mLinkedToDeath = listener;
                 }
-                if (listener->needsReleaseNotify()) {
                     mCore->mConnectedProducerListener = listener;
-                }
             }
             break;
         default:
@@ -1198,9 +1195,9 @@ status_t BufferQueueProducer::disconnect(int api, DisconnectMode mode) {
                     mCore->freeAllBuffersLocked();
 
                     // Remove our death notification callback if we have one
-                    if (mCore->mLinkedToDeath != NULL) {
+                    if (mCore->mConnectedProducerListener != NULL) {
                         sp<IBinder> token =
-                                IInterface::asBinder(mCore->mLinkedToDeath);
+                                IInterface::asBinder(mCore->mConnectedProducerListener);
                         // This can fail if we're here because of the death
                         // notification, but we just ignore it
                         token->unlinkToDeath(
@@ -1208,7 +1205,6 @@ status_t BufferQueueProducer::disconnect(int api, DisconnectMode mode) {
                     }
                     mCore->mSharedBufferSlot =
                             BufferQueueCore::INVALID_BUFFER_SLOT;
-                    mCore->mLinkedToDeath = NULL;
                     mCore->mConnectedProducerListener = NULL;
                     mCore->mConnectedApi = BufferQueueCore::NO_CONNECTED_API;
                     mCore->mConnectedPid = -1;
diff --git a/libs/gui/ConsumerBase.cpp b/libs/gui/ConsumerBase.cpp
index 3cf307834..805a10d1b 100644
--- a/libs/gui/ConsumerBase.cpp
+++ b/libs/gui/ConsumerBase.cpp
@@ -314,23 +314,10 @@ status_t ConsumerBase::addReleaseFenceLocked(int slot,
 
     if (!mSlots[slot].mFence.get()) {
         mSlots[slot].mFence = fence;
-        return OK;
-    }
-
-    auto signaled = mSlots[slot].mFence->hasSignaled();
-
-    if (!signaled) {
-        CB_LOGE("fence has invalid state");
-        return BAD_VALUE;
-    }
-
-    if (*signaled) {
-        mSlots[slot].mFence = fence;
     } else {
-        char fenceName[32] = {};
-        snprintf(fenceName, 32, "%.28s:%d", mName.string(), slot);
         sp<Fence> mergedFence = Fence::merge(
-                fenceName, mSlots[slot].mFence, fence);
+                String8::format("%.28s:%d", mName.string(), slot),
+                mSlots[slot].mFence, fence);
         if (!mergedFence.get()) {
             CB_LOGE("failed to merge release fences");
             // synchronization is broken, the best we can do is hope fences
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 10e999c22..aa0db4506 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -1228,19 +1228,14 @@ EGLImageKHR GLConsumer::EglImage::createImage(EGLDisplay dpy,
         EGL_NONE,
     };
     if (!crop.isValid()) {
-        // No crop rect to set, so leave the crop out of the attrib array. Make
-        // sure to propagate the protected content attrs if they are set.
-        attrs[2] = attrs[10];
-        attrs[3] = attrs[11];
-        attrs[4] = EGL_NONE;
+        // No crop rect to set, so terminate the attrib array before the crop.
+        attrs[2] = EGL_NONE;
     } else if (!isEglImageCroppable(crop)) {
         // The crop rect is not at the origin, so we can't set the crop on the
         // EGLImage because that's not allowed by the EGL_ANDROID_image_crop
         // extension.  In the future we can add a layered extension that
         // removes this restriction if there is hardware that can support it.
-        attrs[2] = attrs[10];
-        attrs[3] = attrs[11];
-        attrs[4] = EGL_NONE;
+        attrs[2] = EGL_NONE;
     }
     eglInitialize(dpy, 0, 0);
     EGLImageKHR image = eglCreateImageKHR(dpy, EGL_NO_CONTEXT,
diff --git a/libs/gui/IGraphicBufferProducer.cpp b/libs/gui/IGraphicBufferProducer.cpp
index 1a08130c4..fca6549c8 100644
--- a/libs/gui/IGraphicBufferProducer.cpp
+++ b/libs/gui/IGraphicBufferProducer.cpp
@@ -26,7 +26,6 @@
 #include <binder/Parcel.h>
 #include <binder/IInterface.h>
 
-#include <gui/BufferQueueDefs.h>
 #include <gui/IGraphicBufferProducer.h>
 #include <gui/IProducerListener.h>
 
@@ -207,12 +206,6 @@ class BpGraphicBufferProducer : public BpInterface<IGraphicBufferProducer>
 
         *slot = reply.readInt32();
         result = reply.readInt32();
-        if (result == NO_ERROR &&
-                (*slot < 0 || *slot >= BufferQueueDefs::NUM_BUFFER_SLOTS)) {
-            ALOGE("attachBuffer returned invalid slot %d", *slot);
-            android_errorWriteLog(0x534e4554, "37478824");
-            return UNKNOWN_ERROR;
-        }
 
         return result;
     }
diff --git a/libs/gui/IProducerListener.cpp b/libs/gui/IProducerListener.cpp
index da54ce1c2..81adc9544 100644
--- a/libs/gui/IProducerListener.cpp
+++ b/libs/gui/IProducerListener.cpp
@@ -22,7 +22,6 @@ namespace android {
 
 enum {
     ON_BUFFER_RELEASED = IBinder::FIRST_CALL_TRANSACTION,
-    NEEDS_RELEASE_NOTIFY,
 };
 
 class BpProducerListener : public BpInterface<IProducerListener>
@@ -38,23 +37,6 @@ class BpProducerListener : public BpInterface<IProducerListener>
         data.writeInterfaceToken(IProducerListener::getInterfaceDescriptor());
         remote()->transact(ON_BUFFER_RELEASED, data, &reply, IBinder::FLAG_ONEWAY);
     }
-
-    virtual bool needsReleaseNotify() {
-        bool result;
-        Parcel data, reply;
-        data.writeInterfaceToken(IProducerListener::getInterfaceDescriptor());
-        status_t err = remote()->transact(NEEDS_RELEASE_NOTIFY, data, &reply);
-        if (err != NO_ERROR) {
-            ALOGE("IProducerListener: binder call \'needsReleaseNotify\' failed");
-            return true;
-        }
-        err = reply.readBool(&result);
-        if (err != NO_ERROR) {
-            ALOGE("IProducerListener: malformed binder reply");
-            return true;
-        }
-        return result;
-    }
 };
 
 // Out-of-line virtual method definition to trigger vtable emission in this
@@ -70,16 +52,8 @@ status_t BnProducerListener::onTransact(uint32_t code, const Parcel& data,
             CHECK_INTERFACE(IProducerListener, data, reply);
             onBufferReleased();
             return NO_ERROR;
-        case NEEDS_RELEASE_NOTIFY:
-            CHECK_INTERFACE(IProducerListener, data, reply);
-            reply->writeBool(needsReleaseNotify());
-            return NO_ERROR;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
 
-bool BnProducerListener::needsReleaseNotify() {
-    return true;
-}
-
 } // namespace android
diff --git a/libs/gui/Surface.cpp b/libs/gui/Surface.cpp
index d423d124a..17c18972a 100644
--- a/libs/gui/Surface.cpp
+++ b/libs/gui/Surface.cpp
@@ -306,12 +306,6 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
         return result;
     }
 
-    if (buf < 0 || buf >= NUM_BUFFER_SLOTS) {
-        ALOGE("dequeueBuffer: IGraphicBufferProducer returned invalid slot number %d", buf);
-        android_errorWriteLog(0x534e4554, "36991414"); // SafetyNet logging
-        return FAILED_TRANSACTION;
-    }
-
     Mutex::Autolock lock(mMutex);
 
     sp<GraphicBuffer>& gbuf(mSlots[buf].buffer);
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index 2b16365c3..d2e7ddedf 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -16,7 +16,7 @@ LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_CLANG := true
-LOCAL_CPPFLAGS := -std=c++1y -Weverything -Werror
+LOCAL_CPPFLAGS := -std=c++1y -Weverything
 # LOCAL_SANITIZE := integer
 
 # The static constructors and destructors in this library have not been noted to
@@ -46,7 +46,10 @@ LOCAL_SRC_FILES := \
 	PixelFormat.cpp \
 	Rect.cpp \
 	Region.cpp \
-	UiConfig.cpp
+	UiConfig.cpp \
+	mediatek/Fence.cpp \
+	mediatek/IDumpTunnel.cpp \
+	mediatek/RefBaseDump.cpp
 
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
diff --git a/libs/ui/Fence.cpp b/libs/ui/Fence.cpp
index 5531b238f..c55abafb7 100644
--- a/libs/ui/Fence.cpp
+++ b/libs/ui/Fence.cpp
@@ -67,12 +67,15 @@ status_t Fence::waitForever(const char* logname) {
     if (err < 0 && errno == ETIME) {
         ALOGE("%s: fence %d didn't signal in %u ms", logname, mFenceFd,
                 warningTimeout);
+	dump(mFenceFd);
         err = sync_wait(mFenceFd, TIMEOUT_NEVER);
     }
     return err < 0 ? -errno : status_t(NO_ERROR);
 }
 
-sp<Fence> Fence::merge(const char* name, const sp<Fence>& f1,
+
+
+sp<Fence> Fence::merge(const String8& name, const sp<Fence>& f1,
         const sp<Fence>& f2) {
     ATRACE_CALL();
     int result;
@@ -80,29 +83,24 @@ sp<Fence> Fence::merge(const char* name, const sp<Fence>& f1,
     // valid fence (e.g. NO_FENCE) we merge the one valid fence with itself so
     // that a new fence with the given name is created.
     if (f1->isValid() && f2->isValid()) {
-        result = sync_merge(name, f1->mFenceFd, f2->mFenceFd);
+        result = sync_merge(name.string(), f1->mFenceFd, f2->mFenceFd);
     } else if (f1->isValid()) {
-        result = sync_merge(name, f1->mFenceFd, f1->mFenceFd);
+        result = sync_merge(name.string(), f1->mFenceFd, f1->mFenceFd);
     } else if (f2->isValid()) {
-        result = sync_merge(name, f2->mFenceFd, f2->mFenceFd);
+        result = sync_merge(name.string(), f2->mFenceFd, f2->mFenceFd);
     } else {
         return NO_FENCE;
     }
     if (result == -1) {
         status_t err = -errno;
         ALOGE("merge: sync_merge(\"%s\", %d, %d) returned an error: %s (%d)",
-                name, f1->mFenceFd, f2->mFenceFd,
+                name.string(), f1->mFenceFd, f2->mFenceFd,
                 strerror(-err), err);
         return NO_FENCE;
     }
     return sp<Fence>(new Fence(result));
 }
 
-sp<Fence> Fence::merge(const String8& name, const sp<Fence>& f1,
-        const sp<Fence>& f2) {
-    return merge(name.string(), f1, f2);
-}
-
 int Fence::dup() const {
     return ::dup(mFenceFd);
 }
@@ -162,7 +160,7 @@ status_t Fence::unflatten(void const*& buffer, size_t& size, int const*& fds, si
         return INVALID_OPERATION;
     }
 
-    if (size < getFlattenedSize()) {
+    if (size < 1) {
         return NO_MEMORY;
     }
 
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index bb860932c..e4971ef58 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -91,6 +91,18 @@ static inline gralloc1_rect_t asGralloc1Rect(const Rect& rect) {
     return outRect;
 }
 
+extern "C" {
+
+extern status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(buffer_handle_t, uint32_t, const Rect&, void**);
+
+status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(buffer_handle_t handle,
+        int usage, const Rect& bounds, void** vaddr)
+{
+    return _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(handle, static_cast<uint32_t>(usage), bounds, vaddr);
+}
+
+}
+
 status_t GraphicBufferMapper::lock(buffer_handle_t handle, uint32_t usage,
         const Rect& bounds, void** vaddr)
 {
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
new file mode 100644
index 000000000..1b832deed
--- /dev/null
+++ b/libs/ui/mediatek/Fence.cpp
@@ -0,0 +1,58 @@
+#define LOG_TAG "Fence"
+
+#include <inttypes.h>
+#include <sync/sync.h>
+#include <ui/Fence.h>
+#include <unistd.h>
+
+#include <cutils/log.h>
+
+// ---------------------------------------------------------------------------
+
+static const char* findKeyWord(const char* msg) {
+    android::String8 obj_name(msg);
+    obj_name.toLower();
+    const char* OBJ_NAME = obj_name.string();
+
+    // NOTE: keep these keywords in sync with MOF
+    android::String8 keyword("timeline_");
+    if (strstr(OBJ_NAME, "surfaceflinger")) {
+        keyword.append("SurfaceFlinger");
+    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
+        keyword.append("ovl_timeline");
+    } else if (strstr(OBJ_NAME, "mali")) {
+        keyword.append("mali");
+    }
+
+    return keyword.string();
+}
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+void Fence::dump(int fd) {
+    if (-1 == fd) return;
+
+    struct sync_fence_info_data *info = sync_fence_info(fd);
+    if (info) {
+        struct sync_pt_info *pt_info = NULL;
+        // status: active(0) signaled(1) error(<0)
+        ALOGI("fence(%s) status(%d)", info->name, info->status);
+
+        // iterate active/error sync points
+        while ((pt_info = sync_pt_info(info, pt_info))) {
+            if (NULL != pt_info && pt_info->status <= 0) {
+                uint64_t ts_sec = pt_info->timestamp_ns / 1000000000LL;
+                uint64_t ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
+
+                ALOGI("sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%" PRIu64 ".%06" PRIu64 ")",
+                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
+                    *reinterpret_cast<uint32_t*>(pt_info->driver_data), ts_sec, ts_usec);
+            }
+        }
+        sync_fence_info_free(info);
+    }
+}
+
+} // namespace android
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
new file mode 100644
index 000000000..1f1d8361c
--- /dev/null
+++ b/libs/ui/mediatek/IDumpTunnel.cpp
@@ -0,0 +1,116 @@
+#define LOG_TAG "DumpTunnel"
+
+#define MTK_LOG_ENABLE 1
+#include <dlfcn.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <cutils/log.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android {
+
+// client : proxy GuiEx class
+class BpDumpTunnel : public BpInterface<IDumpTunnel> {
+public:
+    BpDumpTunnel(const sp<IBinder>& impl)
+        :   BpInterface<IDumpTunnel>(impl) {
+    }
+
+    virtual ~BpDumpTunnel();
+
+    virtual status_t kickDump(String8& result, const char* prefix) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
+        data.writeString8(result);
+        data.writeCString(prefix);
+        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
+        if (err != NO_ERROR) {
+            ALOGE("kickDump could not contact remote\n");
+            return err;
+        }
+        result = reply.readString8();
+        err = reply.readInt32();
+        return err;
+    }
+};
+
+// Out-of-line virtual method definition to trigger vtable emission in this
+// translation unit (see clang warning -Wweak-vtables)
+BpDumpTunnel::~BpDumpTunnel() {}
+
+IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
+
+status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
+    switch (code) {
+        case DUMPTUNNEL_DUMP: {
+            CHECK_INTERFACE(IDumpTunnel, data, reply);
+            String8 result;
+            const char* prefix = NULL;
+            result = data.readString8();
+            prefix = data.readCString();
+
+            status_t ret = kickDump(result, prefix);
+            reply->writeString8(result);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        }
+    }
+    return BBinder::onTransact(code, data, reply, flags);
+}
+
+// ----------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
+
+DumpTunnelHelper::DumpTunnelHelper() :
+    mSoHandle(NULL),
+    mRegDumpPtr(NULL),
+    mUnregDumpPtr(NULL)
+{
+    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
+    typedef bool (*UnregDumpPrototype)(const String8&);
+
+    // dlopen must set RTLD_LAZY flag because of performance issue
+    mSoHandle = dlopen("libgui_ext.so", RTLD_LAZY);
+    if (mSoHandle) {
+        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
+        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
+        if (NULL == mRegDumpPtr) {
+            ALOGE("finding regDump() failed");
+        }
+        if (NULL == mUnregDumpPtr) {
+            ALOGE("finding unregDump() failed");
+        }
+    } else {
+        ALOGE("open libgui_ext failed");
+    }
+}
+
+DumpTunnelHelper::~DumpTunnelHelper() {
+    if(mSoHandle != NULL)
+        dlclose(mSoHandle);
+}
+
+bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
+    bool result = false;
+    if (NULL == mRegDumpPtr) {
+        ALOGE("finding regDump() failed");
+        return result;
+    }
+    result = mRegDumpPtr(tunnel, key);
+
+    return result;
+}
+
+bool DumpTunnelHelper::unregDump(const String8& key) {
+    bool result = false;
+    if (NULL == mUnregDumpPtr) {
+        ALOGE("finding unregDump() failed");
+        return result;
+    }
+    result = mUnregDumpPtr(key);
+
+    return result;
+}
+
+};
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
new file mode 100644
index 000000000..8dcd5abe4
--- /dev/null
+++ b/libs/ui/mediatek/RefBaseDump.cpp
@@ -0,0 +1,70 @@
+#define LOG_TAG "RefBaseDump"
+
+#if 0
+#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
+#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
+#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
+#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
+#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
+#else
+//#define RBD_LOGV(x, ...)
+//#define RBD_LOGD(x, ...)
+#define RBD_LOGI(x, ...)
+//#define RBD_LOGW(x, ...)
+//#define RBD_LOGE(x, ...)
+#endif
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <ui/mediatek/RefBaseDump.h>
+
+namespace android {
+
+
+IMPLEMENT_META_GUIEXTMONITOR(RefBaseMonitor, RefBase*, "RB");
+
+RefBaseMonitor::RefBaseMonitor() {
+    char value[PROPERTY_VALUE_MAX];
+    RBD_LOGI("RefBaseMonitor ctor - %p", this);
+    getProcessName();
+    property_get("debug.rb.dump", value, "Mary had a little lamb");
+    mIsTracking = (-1 != mProcessName.find(value));
+}
+
+
+status_t RefBaseMonitor::monitor(RefBase* pRb) {
+    if (mIsTracking) {
+        pRb->trackMe(true, false);
+    }
+    return GuiExtMonitor<RefBaseMonitor, RefBase*>::monitor(pRb);
+}
+
+
+status_t RefBaseMonitor::dump(String8& result, const char* /*prefix*/) {
+    size_t listSz;
+    RefBase* pRb;
+    Mutex::Autolock _l(mLock);
+    RBD_LOGI("RefBaseMonitor Dump - %p", this);
+    listSz = mItemList.size();
+    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
+    result.append(mIsTracking ? " <- tracking\n" : "\n");
+    result.append("\t  -----------------------\n");
+
+    for (size_t i = 0; i < listSz; i++) {
+        pRb = mItemList.keyAt(i);
+        if (mIsTracking) {
+            pRb->printRefs();
+        }
+        result.appendFormat("\t   %2zu) %8p %4d\n", i, pRb, pRb->getStrongCount());
+    }
+    result.append("\t*****************************************************\n");
+    return NO_ERROR;
+}
+
+
+String8 RefBaseMonitor::getKeyName() const {
+    return String8::format("RB-%p", this);
+}
+
+
+}; // namespace android
diff --git a/opengl/libs/EGL/Loader.cpp b/opengl/libs/EGL/Loader.cpp
index 4234db823..be272354a 100644
--- a/opengl/libs/EGL/Loader.cpp
+++ b/opengl/libs/EGL/Loader.cpp
@@ -125,11 +125,6 @@ static char const * getProcessCmdline() {
     return NULL;
 }
 
-static void* do_dlopen(const char* path, int mode) {
-    ATRACE_CALL();
-    return dlopen(path, mode);
-}
-
 // ----------------------------------------------------------------------------
 
 Loader::driver_t::driver_t(void* gles)
@@ -170,30 +165,14 @@ status_t Loader::driver_t::set(void* hnd, int32_t api)
 // ----------------------------------------------------------------------------
 
 Loader::Loader()
-    : getProcAddress(NULL),
-      mLibGui(nullptr),
-      mGetDriverNamespace(nullptr)
-{
-    // FIXME: See note in GraphicsEnv.h about android_getDriverNamespace().
-    // libgui should already be loaded in any process that uses libEGL, but
-    // if for some reason it isn't, then we're not going to get a driver
-    // namespace anyway, so don't force it to be loaded.
-    mLibGui = dlopen("libgui.so", RTLD_NOLOAD | RTLD_LOCAL | RTLD_LAZY);
-    if (!mLibGui) {
-        ALOGD("failed to load libgui: %s", dlerror());
-        return;
-    }
-    mGetDriverNamespace = reinterpret_cast<decltype(mGetDriverNamespace)>(
-            dlsym(mLibGui, "android_getDriverNamespace"));
+    : getProcAddress(NULL) {
 }
 
 Loader::~Loader() {
-    if (mLibGui)
-        dlclose(mLibGui);
 }
 
 static void* load_wrapper(const char* path) {
-    void* so = do_dlopen(path, RTLD_NOW | RTLD_LOCAL);
+    void* so = dlopen(path, RTLD_NOW | RTLD_LOCAL);
     ALOGE_IF(!so, "dlopen(\"%s\") failed: %s", path, dlerror());
     return so;
 }
@@ -348,7 +327,9 @@ void Loader::init_api(void* dso,
     }
 }
 
-static void* load_system_driver(const char* kind) {
+void *Loader::load_driver(const char* kind,
+        egl_connection_t* cnx, uint32_t mask)
+{
     ATRACE_CALL();
     class MatchFile {
     public:
@@ -465,7 +446,7 @@ static void* load_system_driver(const char* kind) {
     }
     const char* const driver_absolute_path = absolutePath.string();
 
-    void* dso = do_dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
+    void* dso = dlopen(driver_absolute_path, RTLD_NOW | RTLD_LOCAL);
     if (dso == 0) {
         const char* err = dlerror();
         ALOGE("load_driver(%s): %s", driver_absolute_path, err?err:"unknown");
@@ -474,63 +455,11 @@ static void* load_system_driver(const char* kind) {
 
     ALOGD("loaded %s", driver_absolute_path);
 
-    return dso;
-}
-
-static void* do_android_dlopen_ext(const char* path, int mode, const android_dlextinfo* info) {
-    ATRACE_CALL();
-    return android_dlopen_ext(path, mode, info);
-}
-
-static const std::array<const char*, 2> HAL_SUBNAME_KEY_PROPERTIES = {{
-    "ro.hardware.egl",
-    "ro.board.platform",
-}};
-
-static void* load_updated_driver(const char* kind, android_namespace_t* ns) {
-    ATRACE_CALL();
-    const android_dlextinfo dlextinfo = {
-        .flags = ANDROID_DLEXT_USE_NAMESPACE,
-        .library_namespace = ns,
-    };
-    void* so = nullptr;
-    char prop[PROPERTY_VALUE_MAX + 1];
-    for (auto key : HAL_SUBNAME_KEY_PROPERTIES) {
-        if (property_get(key, prop, nullptr) > 0) {
-            String8 name;
-            name.appendFormat("lib%s_%s.so", kind, prop);
-            so = do_android_dlopen_ext(name.string(), RTLD_LOCAL | RTLD_NOW,
-                    &dlextinfo);
-            if (so)
-                return so;
-        }
-    }
-    return nullptr;
-}
-
-void *Loader::load_driver(const char* kind,
-        egl_connection_t* cnx, uint32_t mask)
-{
-    ATRACE_CALL();
-
-    void* dso = nullptr;
-    if (mGetDriverNamespace) {
-        android_namespace_t* ns = mGetDriverNamespace();
-        if (ns) {
-            dso = load_updated_driver(kind, ns);
-        }
-    }
-    if (!dso) {
-        dso = load_system_driver(kind);
-        if (!dso)
-            return NULL;
-    }
-
     if (mask & EGL) {
         getProcAddress = (getProcAddressType)dlsym(dso, "eglGetProcAddress");
 
         ALOGE_IF(!getProcAddress,
-                "can't find eglGetProcAddress() in EGL driver library");
+                "can't find eglGetProcAddress() in %s", driver_absolute_path);
 
         egl_t* egl = &cnx->egl;
         __eglMustCastToProperFunctionPointerType* curr =
diff --git a/opengl/libs/EGL/Loader.h b/opengl/libs/EGL/Loader.h
index 04a8e413a..46ccd06b2 100644
--- a/opengl/libs/EGL/Loader.h
+++ b/opengl/libs/EGL/Loader.h
@@ -25,8 +25,6 @@
 #include <utils/Singleton.h>
 #include <utils/String8.h>
 
-#include <gui/GraphicsEnv.h>
-
 #include <EGL/egl.h>
 
 // ----------------------------------------------------------------------------
@@ -56,9 +54,6 @@ class Loader : public Singleton<Loader>
     
     getProcAddressType getProcAddress;
 
-    void* mLibGui;
-    decltype(android_getDriverNamespace)* mGetDriverNamespace;
-
 public:
     ~Loader();
     
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 0cd8b0235..4cd501399 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -1867,6 +1867,12 @@ EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
                     if (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID) {
                         usage |= GRALLOC_USAGE_HW_TEXTURE;
                     }
+		    // The buffer must be used for either a texture or a
+                    // renderbuffer.
+                    if ((value & EGL_NATIVE_BUFFER_USAGE_RENDERBUFFER_BIT_ANDROID) &&
+                        (value & EGL_NATIVE_BUFFER_USAGE_TEXTURE_BIT_ANDROID)) {
+                        return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
+                    }
                     break;
                 default:
                     return setError(EGL_BAD_PARAMETER, (EGLClientBuffer)0);
diff --git a/vulkan/libvulkan/driver.cpp b/vulkan/libvulkan/driver.cpp
index ba99d0c14..98d8a1ff7 100644
--- a/vulkan/libvulkan/driver.cpp
+++ b/vulkan/libvulkan/driver.cpp
@@ -26,7 +26,6 @@
 
 #include <android/dlext.h>
 #include <cutils/properties.h>
-#include <gui/GraphicsEnv.h>
 
 #include "driver.h"
 #include "stubhal.h"
@@ -129,81 +128,17 @@ class CreateInfoWrapper {
 
 Hal Hal::hal_;
 
-void* LoadLibrary(const android_dlextinfo& dlextinfo,
-                  const char* subname,
-                  int subname_len) {
-    const char kLibFormat[] = "vulkan.%*s.so";
-    char* name = static_cast<char*>(
-        alloca(sizeof(kLibFormat) + static_cast<size_t>(subname_len)));
-    sprintf(name, kLibFormat, subname_len, subname);
-    return android_dlopen_ext(name, RTLD_LOCAL | RTLD_NOW, &dlextinfo);
-}
-
-const std::array<const char*, 2> HAL_SUBNAME_KEY_PROPERTIES = {{
-    "ro.hardware." HWVULKAN_HARDWARE_MODULE_ID,
-    "ro.board.platform",
-}};
-
-int LoadUpdatedDriver(const hw_module_t** module) {
-    const android_dlextinfo dlextinfo = {
-        .flags = ANDROID_DLEXT_USE_NAMESPACE,
-        .library_namespace = android::GraphicsEnv::getInstance().getDriverNamespace(),
-    };
-    if (!dlextinfo.library_namespace)
-        return -ENOENT;
-
-    void* so = nullptr;
-    char prop[PROPERTY_VALUE_MAX];
-    for (auto key : HAL_SUBNAME_KEY_PROPERTIES) {
-        int prop_len = property_get(key, prop, nullptr);
-        if (prop_len > 0) {
-            so = LoadLibrary(dlextinfo, prop, prop_len);
-            if (so)
-                break;
-        }
-    }
-    if (!so)
-        return -ENOENT;
-
-    hw_module_t* hmi = static_cast<hw_module_t*>(dlsym(so, HAL_MODULE_INFO_SYM_AS_STR));
-    if (!hmi) {
-        ALOGE("couldn't find symbol '%s' in HAL library: %s", HAL_MODULE_INFO_SYM_AS_STR, dlerror());
-        dlclose(so);
-        return -EINVAL;
-    }
-    if (strcmp(hmi->id, HWVULKAN_HARDWARE_MODULE_ID) != 0) {
-        ALOGE("HAL id '%s' != '%s'", hmi->id, HWVULKAN_HARDWARE_MODULE_ID);
-        dlclose(so);
-        return -EINVAL;
-    }
-    hmi->dso = so;
-    *module = hmi;
-    ALOGD("loaded updated driver");
-    return 0;
-}
-
 bool Hal::Open() {
     ALOG_ASSERT(!hal_.dev_, "OpenHAL called more than once");
 
     // Use a stub device unless we successfully open a real HAL device.
     hal_.dev_ = &stubhal::kDevice;
 
-    int result;
-    const hwvulkan_module_t* module = nullptr;
-
-    // Use stub HAL if vulkan is disabled
-    bool disableVulkan = property_get_bool("persist.graphics.vulkan.disable", false);
-    if (disableVulkan == true) {
-        ALOGI("no Vulkan HAL present, using stub HAL");
-        return true;
-    }
-
-    result = LoadUpdatedDriver(reinterpret_cast<const hw_module_t**>(&module));
-    if (result == -ENOENT) {
-        result = hw_get_module(HWVULKAN_HARDWARE_MODULE_ID, reinterpret_cast<const hw_module_t**>(&module));
-    }
+    const hwvulkan_module_t* module;
+    int result =
+        hw_get_module("vulkan", reinterpret_cast<const hw_module_t**>(&module));
     if (result != 0) {
-        ALOGV("unable to load Vulkan HAL, using stub HAL (result=%d)", result);
+        ALOGI("no Vulkan HAL present, using stub HAL");
         return true;
     }
 

 
 From b10e3f9fb5f483c684c5f5afd964ddfd965f4570 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Vojt=C4=9Bch=20Hejsek?= <hejsekvojtech@gmail.com>
Date: Tue, 12 Sep 2017 15:25:13 +0300
Subject: [PATCH] Fix what we messed up

This reverts commit 1c193238c9643245bf2f48160051f984891471ee.
---
 include/ui/GraphicBufferMapper.h |  7 -------
 libs/ui/GraphicBufferMapper.cpp  | 12 ------------
 2 files changed, 19 deletions(-)

diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index 30a8a4b8e..4ccc6fddf 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -70,13 +70,6 @@ class GraphicBufferMapper : public Singleton<GraphicBufferMapper>
     std::unique_ptr<Gralloc1::Device> mDevice;
 };
 
-extern "C" {
-
-    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
-            buffer_handle_t handle, int usage, const Rect& bounds, void** vaddr);
-
-}
-
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index e4971ef58..bb860932c 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -91,18 +91,6 @@ static inline gralloc1_rect_t asGralloc1Rect(const Rect& rect) {
     return outRect;
 }
 
-extern "C" {
-
-extern status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(buffer_handle_t, uint32_t, const Rect&, void**);
-
-status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(buffer_handle_t handle,
-        int usage, const Rect& bounds, void** vaddr)
-{
-    return _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(handle, static_cast<uint32_t>(usage), bounds, vaddr);
-}
-
-}
-
 status_t GraphicBufferMapper::lock(buffer_handle_t handle, uint32_t usage,
         const Rect& bounds, void** vaddr)
 {